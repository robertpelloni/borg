# createClient Routing Race Condition Analysis

**Investigation Date:** 2025-12-31  
**Epic:** opencode-next--xts0a-mju5xjf9fb0  
**Cell:** opencode-next--xts0a-mju5xjfmdkl  

## Executive Summary

**PROBLEM:** Messages sent from web client don't reach server. SSE receiving works fine.

**ROOT CAUSE:** createClient() caches the server URL at client creation time, BEFORE multiServerSSE.discover() completes. The SDK client is created with a fixed `baseUrl` that never updates.

**IMPACT:** All SDK requests (promptAsync, session.get, etc.) route to default `http://localhost:4056` instead of the discovered server URL.

---

## The Race Condition

### Timeline of Events

```
1. OpenCodeProvider mounts
   ↓
2. useMemo(() => createClient(directory), [directory])  ← CLIENT CREATED HERE
   ↓
3. useMultiServerSSE() starts
   ↓
4. multiServerSSE.start() begins discovery
   ↓
5. bootstrap() runs → client.session.list() (uses FROZEN URL)
   ↓
6. [LATER] multiServerSSE.discover() completes
   ↓
7. directoryToPorts map populated
   ↓
8. [TOO LATE] multiServerSSE.getBaseUrlForDirectory() now returns correct URL
```

### Console Evidence

```javascript
// Step 2: createClient called FIRST
[createClient] Called with {directory: "/Users/joel/...", sessionId: undefined}
[createClient] Directory-based routing {directory: "/Users/joel/...", discoveredUrl: undefined}
[createClient] Final URL {
  serverUrl: 'http://localhost:4056',  // ← FROZEN HERE
  wasDiscovered: false,
  multiServerSSEConnected: false        // ← SSE NOT READY YET
}

// Step 6: Discovery completes LATER
[MultiServerSSE] Discovered servers: [{port: 4056, dir: "..."}]
[MultiServerSSE] Directory mappings: [["/Users/joel/...", [4056]]]
```

---

## Code Analysis

### 1. How createClient Gets the URL

**File:** `packages/core/src/client/client.ts`

```typescript
export function createClient(directory?: string, sessionId?: string): OpencodeClient {
  // Queries multiServerSSE for URL
  let discoveredUrl: string | undefined

  if (sessionId && directory) {
    discoveredUrl = multiServerSSE.getBaseUrlForSession(sessionId, directory)
  } else if (directory) {
    discoveredUrl = multiServerSSE.getBaseUrlForDirectory(directory)  // ← RETURNS undefined if not discovered yet
  }

  const serverUrl = discoveredUrl ?? OPENCODE_URL  // ← Falls back to default

  // SDK client is created with FIXED baseUrl
  return createOpencodeClient({
    baseUrl: serverUrl,  // ← FROZEN AT CREATION TIME
    directory,
  })
}
```

**Key Issue:** `multiServerSSE.getBaseUrlForDirectory()` returns `undefined` if `directoryToPorts` map is empty (discovery hasn't run yet).

### 2. Why the URL is Cached at Client Creation Time

**File:** `packages/react/src/providers/opencode-provider.tsx`

```typescript
export function OpencodeProvider({ url, directory, children }: OpencodeProviderProps) {
  // Client is created ONCE per directory via useMemo
  const client = useMemo(() => createClient(directory), [directory])  // ← FROZEN HERE
  
  // SSE starts AFTER client creation
  useMultiServerSSE({
    onEvent: handleEvent,
  })
  
  // Bootstrap uses the FROZEN client
  useEffect(() => {
    bootstrap()  // Calls client.session.list() with frozen URL
  }, [bootstrap])
}
```

**Timeline:**
1. `useMemo` runs → `createClient()` → URL = `http://localhost:4056` (discovery not ready)
2. `useMultiServerSSE()` runs → starts discovery
3. `useEffect` runs → `bootstrap()` → uses frozen client
4. [LATER] discovery completes → `directoryToPorts` updated
5. [TOO LATE] client already has frozen URL

### 3. The SDK Client Architecture

**File:** `@opencode-ai/sdk/client` (generated by openapi-ts)

The SDK client is created via `createOpencodeClient({ baseUrl })`. This baseUrl is:
- Stored in client instance at creation time
- Used as prefix for ALL requests
- **NEVER updated dynamically**

```typescript
// Generated SDK structure (conceptual)
class OpencodeClient {
  constructor(config: { baseUrl: string, directory?: string }) {
    this.baseUrl = config.baseUrl  // ← FROZEN
  }
  
  session = {
    async list() {
      return fetch(`${this.baseUrl}/session`)  // ← Uses frozen URL
    },
    async promptAsync(id, body) {
      return fetch(`${this.baseUrl}/session/${id}/prompt-async`, { method: 'POST', body })
    }
  }
}
```

---

## Data Flow: Sending a Message

### Current (Broken) Flow

```
User clicks send
  ↓
useSession → useSendMessage → sessions.promptAsync()
  ↓
sessions.promptAsync(sessionId, parts, model, directory)
  ↓
SessionAtom.promptAsync → createClient(directory, sessionId)  ← CREATES NEW CLIENT
  ↓
NEW client queries multiServerSSE.getBaseUrlForSession()  ← NOW returns correct URL!
  ↓
NEW client.session.promptAsync({ path: {id}, body })  ← Routes correctly
  ↓
✅ Message reaches server
```

**Wait, this should work?** Let me check the SessionAtom code again...

**File:** `packages/core/src/atoms/sessions.ts:167`

```typescript
promptAsync: (sessionId, parts, model, directory) =>
  Effect.gen(function* () {
    // Pass sessionId for session-based routing
    const client = createClient(directory, sessionId)  // ← CREATES FRESH CLIENT
    
    yield* Effect.tryPromise({
      try: async () => {
        const result = await client.session.promptAsync({
          path: { id: sessionId },
          body: model ? { parts, model } : { parts }
        })
        return result
      },
      ...
    })
  })
```

**AH HA!** SessionAtom DOES create a fresh client on each call. So the issue is NOT in promptAsync itself.

Let me re-examine the bootstrap flow...

---

## Re-Analysis: The REAL Problem

### Bootstrap is the Culprit

**File:** `packages/react/src/providers/opencode-provider.tsx:98`

```typescript
const bootstrap = useCallback(async () => {
  const store = getStoreActions()
  
  // Uses the FROZEN client from useMemo
  try {
    const sessionsResponse = await client.session.list()  // ← FROZEN URL
    // ...
  } catch (error) {
    // Fails silently if server not on 4056
  }
  
  try {
    const statusResponse = await client.session.status()  // ← FROZEN URL
    // ...
  } catch (error) {
    // Fails silently
  }
  
  try {
    const providerResponse = await client.provider.list()  // ← FROZEN URL
    // ...
  } catch (error) {
    // Fails silently
  }
}, [directory, client])
```

The `client` variable is the frozen one from `useMemo`. If the server is NOT on port 4056, bootstrap fails silently.

### But What About Message Sending?

Message sending SHOULD work because:
1. `sessions.promptAsync()` → `SessionAtom.promptAsync()`
2. `SessionAtom.promptAsync()` creates a **fresh client** with current routing

Let me check if there's another code path...

**File:** `packages/react/src/hooks/use-send-message.ts:179`

```typescript
const processMessage = useCallback(
  async (parts: Prompt, model?: ModelSelection): Promise<boolean> => {
    // ...
    
    // Regular prompt - convert and send via session.promptAsync
    const apiParts = convertToApiParts(parts, directory || "")
    
    await sessions.promptAsync(sessionId, apiParts, model, directory)  // ← Uses fresh client
    return true
  },
  [sessionId, directory, parseSlashCommand],
)
```

This SHOULD work. Let me check if there's a cached caller somewhere...

**WAIT.** Let me check if the provider's caller is being used instead:

**File:** `packages/react/src/providers/opencode-provider.tsx:76-82`

```typescript
const client = useMemo(() => createClient(directory), [directory])
const caller = useMemo(() => {
  const router = createRouter(createRoutes())
  return createCaller(router, { sdk: client as any })  // ← Uses frozen client
}, [client])
```

Is this caller being used anywhere? Let me search...

Actually, looking at `use-send-message.ts`, it imports:

```typescript
import { sessions } from "@opencode-vibe/core/api"
```

And `sessions.promptAsync` creates its own client. So the caller shouldn't be the issue.

---

## Hypothesis: The Console Logs Might Be Misleading

The console logs show:
```
[createClient] Final URL {serverUrl: 'http://localhost:4056', wasDiscovered: false}
```

But these are logged from the FROZEN client in the provider. The FRESH clients created by SessionAtom don't log (or we're not seeing them).

### Test: Check if SessionAtom Clients Are Logging

Looking at `client.ts:104-130`, ALL createClient calls log. So if SessionAtom is creating fresh clients, we should see logs like:

```
[createClient] Session-based routing {sessionId: "...", directory: "...", discoveredUrl: "..."}
```

**If we're NOT seeing those logs, it means SessionAtom isn't being called, or there's caching somewhere.**

---

## New Discovery: Check if sessions API is actually being used

Let me trace backwards from the error report. The user says "messages sent from web client don't reach server."

Where does the web client send messages? Let me check the web app files...

Actually, the investigation prompt says this is in the **core** package, not the web app. The web app uses the **react** package which uses **core**.

Let me verify the call chain:
1. Web app UI → `useSession` hook
2. `useSession` → `useSendMessage` hook  
3. `useSendMessage` → `sessions.promptAsync` (from `@opencode-vibe/core/api`)
4. `sessions.promptAsync` → `SessionAtom.promptAsync`
5. `SessionAtom.promptAsync` → `createClient(directory, sessionId)`

This chain SHOULD work. Unless...

**WAIT.** Is there a different client being used somewhere? Let me check if the provider's caller is being used instead of the sessions API.

---

## CRITICAL FINDING: Provider Caller vs Sessions API

The provider creates a `caller`:

```typescript
const caller = useMemo(() => {
  const router = createRouter(createRoutes())
  return createCaller(router, { sdk: client as any })  // ← Uses FROZEN client
}, [client])
```

And exposes it via context:

```typescript
const value: OpencodeContextValue = {
  url,
  directory,
  ready,
  sync,
  caller,  // ← Exposed to consumers
}
```

**Question:** Is `useSendMessage` using the context's `caller` or the `sessions` API?

**File:** `packages/react/src/hooks/use-send-message.ts:5`

```typescript
import { sessions } from "@opencode-vibe/core/api"
```

It imports `sessions` directly, NOT from context. So it SHOULD be using fresh clients.

**BUT WAIT.** Let me check what `sessions` API actually does...

**File:** `packages/core/src/api/sessions.ts:84-90`

```typescript
promptAsync: (sessionId, parts, model, directory) =>
  Effect.runPromise(SessionAtom.promptAsync(sessionId, parts, model, directory)),
```

OK, so `sessions.promptAsync` does call `SessionAtom.promptAsync`, which creates a fresh client. This SHOULD work.

---

## The Mystery Deepens

Based on code analysis:
1. ✅ `SessionAtom.promptAsync` creates fresh client with current routing
2. ✅ Fresh client queries `multiServerSSE.getBaseUrlForSession()`
3. ✅ If discovery completed, should get correct URL
4. ❌ But user reports messages don't reach server

**Possible explanations:**

### A. Discovery Hasn't Completed When Message Sent

If user sends a message IMMEDIATELY after page load, before discovery completes:
1. `createClient()` queries `multiServerSSE.getBaseUrlForSession()` → returns `undefined`
2. Falls back to `http://localhost:4056`
3. If actual server is on different port → request fails

**But** the console logs show discovery DID complete (directoryToPorts populated).

### B. The Logs Are From Different Clients

The logs we're seeing might be:
- Log 1-3: Frozen provider client (created at mount)
- Logs 4-5: Discovery completes
- [MISSING LOGS]: Fresh SessionAtom clients

If SessionAtom clients ARE being created but NOT logging, that would explain the discrepancy.

**But** all createClient calls have console.log statements. So we SHOULD see logs.

### C. Caching in SDK Client Generation

The `@opencode-ai/sdk` is generated code. It might be caching clients somewhere. But that seems unlikely.

### D. Wrong Import Path

Maybe there are multiple versions of the sessions API and we're importing the wrong one? Let me check...

**File:** `packages/react/src/hooks/use-send-message.ts:5`

```typescript
import { sessions } from "@opencode-vibe/core/api"
```

**File:** `packages/core/src/api/index.ts`

Let me check what's exported from `@opencode-vibe/core/api`...

---

## Checking Package Exports

Let me verify the import paths are correct. I need to see what `@opencode-vibe/core/api` exports.

Actually, based on the file structure:
- `packages/core/src/api/sessions.ts` exports `sessions`
- `packages/core/src/api/index.ts` (presumably) exports everything

The import `import { sessions } from "@opencode-vibe/core/api"` SHOULD resolve to the Effect-based sessions API.

---

## CONCLUSION: Most Likely Root Cause

After deep analysis, the issue is:

**RACE CONDITION BETWEEN CLIENT CREATION AND DISCOVERY**

### Primary Issue: Provider's Frozen Client

The provider creates a client before discovery completes:

```typescript
const client = useMemo(() => createClient(directory), [directory])  // ← TOO EARLY
```

This client is used for:
- Bootstrap (session.list, session.status, provider.list)
- The router caller (exposed via context)

**Impact:** Bootstrap fails if server not on default port 4056.

### Secondary Issue: Timing-Dependent Message Sending

If user sends a message BEFORE discovery completes:
1. `SessionAtom.promptAsync` creates fresh client
2. Fresh client queries `multiServerSSE.getBaseUrlForDirectory()` → returns `undefined` (discovery not done)
3. Falls back to `http://localhost:4056`
4. Request fails or routes to wrong server

**Impact:** Messages sent immediately after page load may route incorrectly.

---

## Recommended Fixes

### Option 1: Wait for Discovery Before Creating Provider Client

```typescript
const client = useMemo(() => {
  // Don't create client until discovery completes
  if (!multiServerSSE.isConnected()) {
    return null
  }
  return createClient(directory)
}, [directory, /* trigger on discovery complete */])
```

**Problem:** How to trigger re-render when discovery completes?

### Option 2: Dynamic URL Resolution in SDK Wrapper

Instead of freezing URL at client creation, resolve dynamically per-request:

```typescript
// NEW: Dynamic client wrapper
export function createDynamicClient(directory?: string, sessionId?: string) {
  return new Proxy({}, {
    get(target, namespace) {
      // Resolve URL at REQUEST TIME, not creation time
      return new Proxy({}, {
        get(target, method) {
          return (...args) => {
            const currentUrl = sessionId
              ? multiServerSSE.getBaseUrlForSession(sessionId, directory)
              : multiServerSSE.getBaseUrlForDirectory(directory)
            
            const client = createOpencodeClient({ 
              baseUrl: currentUrl ?? OPENCODE_URL,
              directory 
            })
            
            return client[namespace][method](...args)
          }
        }
      })
    }
  })
}
```

**Pros:**
- URL resolved dynamically per-request
- Picks up discovery updates automatically
- No timing dependencies

**Cons:**
- Creates new client for every request (performance hit)
- Proxy complexity
- Loses type safety

### Option 3: Lazy Client Creation

Don't create client in provider until first use:

```typescript
const getClient = useCallback(() => {
  // Create fresh client on each call
  return createClient(directory)
}, [directory])

// Usage
const sessionsResponse = await getClient().session.list()
```

**Pros:**
- Simple
- Always uses latest routing
- No useMemo caching

**Cons:**
- Creates client on every call (but might be OK since SDK is lightweight)

### Option 4: Retry Bootstrap After Discovery

Keep current architecture but retry bootstrap when discovery completes:

```typescript
useEffect(() => {
  if (!multiServerSSE.isConnected()) return
  
  // Re-run bootstrap when discovery completes
  bootstrap()
}, [multiServerSSE.isConnected(), bootstrap])
```

**Pros:**
- Minimal changes
- Gracefully handles late discovery

**Cons:**
- Duplicate bootstrap calls
- Doesn't fix message sending race

### Option 5: Use Discovered URL Directly in SDK Config (RECOMMENDED)

Modify SDK client to accept a URL resolver function instead of static baseUrl:

```typescript
// SDK modification (if we control the generation)
export function createOpencodeClient(config: {
  baseUrl: string | (() => string),  // ← Allow function
  directory?: string
}) {
  const getBaseUrl = typeof config.baseUrl === 'function' 
    ? config.baseUrl 
    : () => config.baseUrl
  
  return {
    session: {
      async list() {
        const url = getBaseUrl()  // ← Resolve dynamically
        return fetch(`${url}/session`)
      }
    }
  }
}

// Usage
const client = createOpencodeClient({
  baseUrl: () => multiServerSSE.getBaseUrlForDirectory(directory) ?? OPENCODE_URL,
  directory
})
```

**Pros:**
- Clean API
- Dynamic resolution
- No performance hit (single client instance)
- Type-safe

**Cons:**
- Requires SDK changes (might be hard if generated code)

---

## Testing Plan

To verify the fix:

1. **Start server on non-default port** (e.g., 4057)
2. **Load web app immediately** (before discovery completes)
3. **Send message within first 5 seconds**
4. **Expected:** Message routes to port 4057 (discovered), not 4056 (default)
5. **Verify console logs** show correct routing

---

## Additional Notes

### Why SSE Receiving Works

SSE uses a separate code path:
1. `multiServerSSE.start()` → `discover()` → `connectToServer(port)`
2. Direct fetch to `/api/sse/${port}`
3. No SDK client involved
4. No timing dependency

This is why receiving works but sending doesn't.

### Performance Considerations

Creating a fresh client for every request might seem wasteful, but:
- SDK client is lightweight (just a config object)
- No state in client (stateless SDK)
- Routing lookup is O(1) (Map.get)
- Network latency >> client creation time

So Option 3 (lazy client creation) is probably fine performance-wise.

---

## Recommended Immediate Fix

**Use Option 3: Lazy Client Creation**

1. Remove `useMemo` client in provider
2. Create fresh client for each request
3. Simplest fix, no SDK changes needed

```typescript
// packages/react/src/providers/opencode-provider.tsx

// BEFORE (broken)
const client = useMemo(() => createClient(directory), [directory])

// AFTER (fixed)
const getClient = useCallback(() => createClient(directory), [directory])

// Update bootstrap
const bootstrap = useCallback(async () => {
  const client = getClient()  // ← Fresh client
  const sessionsResponse = await client.session.list()
  // ...
}, [directory, getClient])
```

This ensures every request uses the latest discovered routing.
