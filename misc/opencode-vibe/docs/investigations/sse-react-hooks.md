# React SSE Hooks Architecture Investigation

**Agent:** CoolHawk  
**Cell:** opencode-next--xts0a-mjusjggpb6z  
**Date:** 2025-12-31

## Executive Summary

The React SSE integration uses a **layered hook architecture** with clear separation of concerns:

1. **Core/Singleton Layer**: `multiServerSSE` singleton from `@opencode-vibe/core/sse` (port 4056-4066 discovery, SSE connections)
2. **Internal Hooks Layer**: Low-level hooks for SSE connection management (`use-sse.ts`, `use-multi-server-sse.ts`)
3. **Store Layer**: Zustand + Immer store with directory-scoped state (`store.ts`, `types.ts`)
4. **Factory/Public Hooks Layer**: User-facing hooks generated by `generateOpencodeHelpers()` in `factory.ts`
5. **Provider Layer**: `OpencodeProvider` wires SSE â†’ Store, handles bootstrap

**Key Insight**: Session status is derived from THREE sources:
1. Store's `sessionStatus` map (from SSE `session.status` events)
2. Last message completion state (used in bootstrap)
3. Sub-agent activity (task parts with `status === "running"`)

The architecture successfully avoids directory-filtering bugs by processing events for ALL directories and using store's auto-initialization pattern.

---

## Hook Hierarchy

### Layer 1: Core Singleton (from @opencode-vibe/core)

**`multiServerSSE` singleton**
- **Location**: `@opencode-vibe/core/sse`
- **Purpose**: Discover and connect to multiple OpenCode servers (ports 4056-4066)
- **API**:
  - `start()` - Idempotent initialization
  - `onEvent(callback)` - Subscribe to all SSE events from all servers
  - `isConnected()` - Connection state
  - `getConnectionStatus()` - Map of port â†’ connection state
  - `isDiscoveryComplete()` - Discovery phase complete

### Layer 2: Internal Hooks (packages/react/src/hooks/internal)

#### `use-sse.ts` - Native EventSource Hook

**Purpose**: Low-level SSE connection using browser's native `EventSource` API

**Interface**:
```typescript
interface UseSSEOptions {
  url: string
  heartbeatTimeout?: number // Default: 60000ms
}

interface UseSSEReturn {
  events: GlobalEvent[]      // Ring buffer (max 100)
  connected: boolean
  error: Error | null
}
```

**Features**:
- Heartbeat monitoring (60s timeout, resets on each event)
- Ring buffer to prevent memory leaks (caps at 100 events)
- Automatic cleanup on unmount

**Status**: **DEPRECATED** in factory.ts (line 699-701). Use `useSSESync()` instead.

**Why deprecated?**
> Components should use store selectors, not raw SSE events. The store is the single source of truth.

---

#### `use-multi-server-sse.ts` - Multi-Server Wrapper

**Purpose**: React hook wrapper for `multiServerSSE` singleton

**Interface**:
```typescript
interface UseMultiServerSSEOptions {
  onEvent?: (event: GlobalEvent) => void
}

function useMultiServerSSE(options?: UseMultiServerSSEOptions): void
```

**Behavior**:
1. Calls `multiServerSSE.start()` (idempotent)
2. Subscribes to `multiServerSSE.onEvent()` if callback provided
3. Returns `void` (side-effect only hook)

**Used by**: `OpencodeProvider` (via `useSSESync` in factory)

---

#### `use-session-status.ts` - Store Selector Hook

**Purpose**: Select session status from Zustand store

**Interface**:
```typescript
function useSessionStatus(sessionId: string): SessionStatus
```

**Dependencies**:
- `useOpencode()` - Gets directory from context
- `useOpencodeStore()` - Selects from `state.directories[directory].sessionStatus[sessionId]`

**Default**: Returns `"completed"` if session not found

**Status**: **INTERNAL** - Not exposed in factory (superseded by factory's `useSessionStatus` with sub-agent detection)

---

### Layer 3: Store (packages/react/src/store)

#### `store.ts` - Zustand Store

**State Structure**:
```typescript
type OpencodeState = {
  directories: Record<string, DirectoryState>
}

interface DirectoryState {
  ready: boolean
  sessions: Session[]                           // Sorted by ID (ULID)
  sessionStatus: Record<string, SessionStatus>  // "running" | "completed"
  sessionLastActivity: Record<string, number>   // Timestamp
  sessionDiff: Record<string, FileDiff[]>
  todos: Record<string, Todo[]>
  messages: Record<string, Message[]>           // Keyed by sessionID
  parts: Record<string, Part[]>                 // Keyed by messageID
  contextUsage: Record<string, ContextUsage>
  compaction: Record<string, CompactionState>
  modelLimits: Record<string, { context: number; output: number }>
}
```

**Key Actions**:
- `initDirectory(directory)` - Create empty directory state (idempotent)
- `handleSSEEvent(event: GlobalEvent)` - **PRIMARY SSE INTEGRATION POINT**
- `handleEvent(directory, event)` - Route event to specific handler
- `setSessions`, `setMessages`, `setParts` - Bulk updates (sorted)
- `hydrateMessages` - RSC initial data (prevents "blink" on page load)

**Binary Search**: All arrays sorted by ID for O(log n) updates using `Binary.search()` from `@opencode-vibe/core`

---

#### `types.ts` - Type Definitions

**Core Types**:
- `Session` - Session metadata (id, title, directory, time)
- `Message` - Message metadata (id, sessionID, role, time, tokens, model)
- `Part` - Streaming content (id, messageID, type, content, state)
- `SessionStatus` - Literal type: `"pending" | "running" | "completed" | "error"`
- `GlobalEvent` - SSE event wrapper: `{ directory: string, payload: { type: string, properties: any } }`

**Derived Types**:
- `ContextUsage` - Token usage stats (used, limit, percentage, isNearLimit)
- `CompactionState` - Compaction progress (isCompacting, isAutomatic, progress)
- `FileDiff` - Changed files (path, additions, deletions)

---

### Layer 4: Factory Hooks (packages/react/src/factory.ts)

#### `generateOpencodeHelpers()` - Factory Function

**Purpose**: Generate provider-free hooks with config scoping

**Pattern**: Inspired by uploadthing's `generateReactHelpers` approach

**Generated Hooks**:

##### Data Access:
- `useSession(sessionId)` - Get session by ID
- `useMessages(sessionId)` - Get messages for session
- `useMessagesWithParts(sessionId)` - Messages + parts joined
- `useSessionList()` - All sessions (excludes archived)

##### SSE/Connection:
- **`useSSESync()`** - **PRIMARY HOOK** - Starts multiServerSSE, routes events to store
- `useSSE(options)` - **DEPRECATED** - Use `useSSESync()` instead
- `useConnectionStatus()` - SSE connection state (connected, serverCount, discovering)

##### Status/Metadata:
- **`useSessionStatus(sessionId)`** - **WITH SUB-AGENT DETECTION**
- `useCompactionState(sessionId)` - Compaction progress
- `useContextUsage(sessionId)` - Token usage
- `useLiveTime(interval)` - Re-render interval (for relative times)

##### Actions:
- `useSendMessage({ sessionId })` - FIFO queue with slash command detection
- `useCreateSession()` - Create new session
- `useFileSearch(query)` - Fuzzy file search

##### Multi-Directory:
- `useMultiDirectorySessions(directories)` - Sessions from multiple directories
- `useMultiDirectoryStatus(directories)` - Statuses with 1-minute cooldown

---

### Layer 5: Provider (packages/react/src/providers)

#### `OpencodeProvider` - Top-Level Integration

**Purpose**: Wire SSE â†’ Store, handle bootstrap, provide context

**Responsibilities**:
1. **Initialize directory state** (`store.initDirectory(directory)`)
2. **Bootstrap initial data** (sessions, statuses, model limits)
3. **Subscribe to SSE events** (via `useMultiServerSSE`)
4. **Route events to store** (`store.handleSSEEvent(event)`)
5. **Provide context** ({ url, directory, ready, sync, caller })

**Key Pattern**: Uses `getStoreActions()` helper to get stable action references (avoids re-render loops)

**Bootstrap Strategy**:
- Load sessions (first 20 + any updated in last 4 hours)
- Load session statuses separately (non-critical)
- Load provider data to cache model limits (for context usage)
- Gracefully handles network failures (app remains usable, SSE provides updates)

**Sync Strategy** (`sync(sessionID)`):
- Fetches messages, parts, todos, diffs in parallel (`Promise.allSettled`)
- Handles partial failures gracefully
- Called manually when user navigates to session page

---

## Session Status Derivation Logic

### Three-Source Status Resolution

**Factory's `useSessionStatus(sessionId)` (lines 728-761)**:

```typescript
function useSessionStatus(sessionId: string): SessionStatus {
  const cfg = getOpencodeConfig(config)
  return useOpencodeStore(
    useCallback(
      (state) => {
        const dir = state.directories[cfg.directory]
        if (!dir) return "completed"

        // SOURCE 1: Main session status from store
        const mainStatus = dir.sessionStatus[sessionId] ?? "completed"
        if (mainStatus === "running") return "running"

        // SOURCE 2: Sub-agent activity (task parts)
        const messages = dir.messages[sessionId]
        if (!messages) return mainStatus

        for (const message of messages) {
          const parts = dir.parts[message.id]
          if (!parts) continue

          for (const part of parts) {
            // SOURCE 3: Check if any task part is running
            if (part.type === "tool" && part.tool === "task" && part.state.status === "running") {
              return "running"
            }
          }
        }

        return mainStatus
      },
      [sessionId, cfg.directory],
    ),
  )
}
```

**Status Priority**:
1. **Main session running?** â†’ Return `"running"` immediately
2. **Any sub-agent running?** â†’ Search all task parts, return `"running"` if found
3. **Otherwise** â†’ Return main status (usually `"completed"`)

**Why sub-agent detection?**  
Sub-agents (spawned via Task tool) run independently but should keep the session indicator green. Without this check, the UI would show "idle" while sub-agents are actively working.

---

### Multi-Directory Status with Cooldown

**`useMultiDirectoryStatus` (use-multi-directory-status.ts)**:

**Purpose**: Track session status across multiple directories with UX smoothing

**Two-Phase Approach**:
1. **Bootstrap (on mount)**: Fetch status for recent sessions (<5min old) by checking if last message is incomplete
2. **SSE subscription**: Subscribe to store updates (fed by `useSSESync`)

**Cooldown Logic** (1-minute):
- When status = `"running"`: Immediately set, cancel any pending cooldown
- When status = `"completed"`: Start 1-minute timer, keep indicator green until timer expires

**Why cooldown?**
> Prevents UI flicker when AI streaming pauses briefly between chunks. Without cooldown, the green dot would flash on/off rapidly during normal streaming, creating janky UX.

**Tradeoff**: Indicator may stay green for up to 1 minute after session actually completes. This is acceptable for better perceived smoothness.

**Status Derivation** (bootstrap phase):
```typescript
function deriveSessionStatus(messages): "running" | "completed" {
  const lastMessage = messages[messages.length - 1]
  if (!lastMessage) return "completed"

  // Session is busy if last message is assistant without completed time
  if (lastMessage.info.role === "assistant" && !lastMessage.info.time?.completed) {
    return "running"
  }

  return "completed"
}
```

---

## Store Structure for SSE State

### Directory-Scoped State Pattern

**Key Design Decision**: Multi-directory support

Each directory has **isolated state** with its own sessions, messages, parts, etc. This enables:
- Multi-project UIs (project list showing status for multiple OpenCode instances)
- Cross-directory updates (SSE events for ANY directory are processed)
- Per-directory caching (model limits, context usage)

### Auto-Initialization Pattern

**`handleSSEEvent` (lines 808-822)**:
```typescript
handleSSEEvent: (event) => {
  // CRITICAL: Auto-initialize directory if it doesn't exist
  if (!get().directories[event.directory]) {
    set((state) => {
      state.directories[event.directory] = createEmptyDirectoryState()
    })
  }
  get().handleEvent(event.directory, event.payload)
}
```

**Why auto-initialize?**
> Guarantees directory state exists before processing events. Without this, events for new directories would be silently dropped.

**Enables cross-directory updates**: Project list can show status updates for multiple OpenCode instances on different ports, even if user hasn't visited those projects yet.

---

### Event Routing (`handleEvent`)

**Central dispatcher** (lines 218-490) with switch statement:

**Session Events**:
- `session.created` / `session.updated` â†’ Binary search insert/update in `sessions` array
- `session.status` â†’ Update `sessionStatus[sessionID]` + `sessionLastActivity[sessionID]`
- `session.diff` â†’ Update `sessionDiff[sessionID]`
- `session.deleted` â†’ Binary search remove from `sessions`
- `session.compacted` â†’ Clear `compaction[sessionID]`

**Message Events**:
- `message.updated` â†’ Binary search insert/update in `messages[sessionID]`, extract token usage
- `message.removed` â†’ Binary search remove

**Part Events** (streaming):
- `message.part.updated` â†’ Binary search insert/update in `parts[messageID]`
- `message.part.removed` â†’ Binary search remove

**Todo Events**:
- `todo.updated` â†’ Update `todos[sessionID]`

**Status Normalization** (lines 254-289):

Backend can send status in different formats:
- `{ type: "busy" | "retry" | "idle" }` from `/session/status` endpoint
- `{ running: boolean }` from SSE events
- String literal (for tests or future API changes)

All formats are normalized to `SessionStatus` ("running" | "completed").

---

### Token Usage Calculation

**On `message.updated` event** (lines 336-380):

```typescript
if (message.tokens) {
  const tokens = message.tokens
  let limits: { context: number; output: number } | undefined

  // First try: message.model.limits (if backend sends it)
  if (message.model?.limits) {
    limits = message.model.limits
    // Cache for future use
    if (message.model.name) {
      dir.modelLimits[message.model.name] = limits
    }
  }
  // Second try: cached limits by modelID
  else {
    const modelID = message.modelID as string | undefined
    if (modelID && dir.modelLimits[modelID]) {
      limits = dir.modelLimits[modelID]
    }
  }

  // Calculate context usage if we have limits
  if (limits) {
    const used = tokens.input + (tokens.cache?.read || 0) + tokens.output
    const usableContext = limits.context - Math.min(limits.output, 32000)
    const percentage = Math.round((used / usableContext) * 100)

    dir.contextUsage[sessionID] = {
      used,
      limit: limits.context,
      percentage,
      isNearLimit: percentage >= 80,
      tokens: {
        input: tokens.input,
        output: tokens.output,
        cached: tokens.cache?.read || 0,
      },
      lastUpdated: Date.now(),
    }
  }
}
```

**Model limits caching**: Populated during bootstrap by fetching providers, then cached in `modelLimits` map for fast lookup.

---

## Multi-Server Connection Handling

### Discovery + Connection Flow

**`multiServerSSE.start()` (from core)**:
1. Scans ports 4056-4066 for running OpenCode servers
2. Connects to each discovered server's `/sse` endpoint
3. Aggregates events from all servers into single event stream
4. Marks discovery complete when scan finishes

### React Integration

**`useSSESync()` in factory** (lines 970-1015):

```typescript
function useSSESync(): void {
  const cfg = getOpencodeConfig(config)

  // Start MultiServerSSE singleton (idempotent)
  useEffect(() => {
    console.log("[useSSESync] Starting multiServerSSE")
    multiServerSSE.start()
  }, [])

  // Subscribe to events and route to store
  useEffect(() => {
    console.log("[useSSESync] Subscribing to SSE events (all directories)")

    const unsubscribe = multiServerSSE.onEvent((event) => {
      // Process events for ALL directories
      console.log("[useSSESync] Received event for", event.directory, ":", event.payload.type)

      // Route to store (getState() for stable reference)
      useOpencodeStore.getState().handleSSEEvent({
        directory: event.directory,
        payload: event.payload,
      })
    })

    return () => {
      console.log("[useSSESync] Unsubscribing from SSE events")
      unsubscribe()
    }
  }, [])
}
```

**Key Behaviors**:
- **No directory filtering** - Subscribes to ALL events from ALL directories
- **Uses `getState()`** - Avoids dependency on hook return value (prevents re-subscriptions on every store update)
- **Auto-initialization** - Store's `handleSSEEvent` auto-creates directory state if needed

**Why no filtering?**
> The store's `handleSSEEvent` auto-initializes directory state, so events for any directory are safe to process. This allows the UI to react to changes in other projects (e.g., showing when a background session starts running).

---

### Connection Status Hook

**`useConnectionStatus()` in factory** (lines 868-911):

```typescript
function useConnectionStatus(): {
  connected: boolean
  serverCount: number
  discovering: boolean
} {
  // SSR-safe initial state
  const [state, setState] = useState(() => {
    if (typeof window === "undefined") {
      return { connected: false, serverCount: 0, discovering: true }
    }
    return {
      connected: multiServerSSE.isConnected(),
      serverCount: multiServerSSE.getConnectionStatus().size,
      discovering: !multiServerSSE.isDiscoveryComplete(),
    }
  })

  useEffect(() => {
    const updateState = () => {
      setState({
        connected: multiServerSSE.isConnected(),
        serverCount: multiServerSSE.getConnectionStatus().size,
        discovering: !multiServerSSE.isDiscoveryComplete(),
      })
    }

    updateState()
    const interval = setInterval(updateState, 1000) // Poll every 1s
    return () => clearInterval(interval)
  }, [])

  return state
}
```

**Polling approach**: `multiServerSSE` doesn't expose state change events, so hook polls every 1 second.

**SSR safety**: Returns safe defaults during server render, hydrates with actual state on client.

---

## Key Learnings & Patterns

### 1. No Directory Filtering at Subscription Layer

**Pattern**: Subscribe to ALL events, let store handle routing

**Rationale**: Enables cross-directory features (project list showing status for multiple instances)

**Implementation**:
- `useSSESync()` subscribes without filter
- Store's `handleSSEEvent` auto-initializes directory if needed
- Components use directory-scoped selectors to filter

**Previous bug**: Early version had `if (event.directory !== cfg.directory) return` in subscription, which broke cross-directory updates.

**Fix**: Removed filter, let store handle all directories via auto-initialization.

---

### 2. Zustand Store Gotcha - getState() Pattern

**Problem**: `useOpencodeStore()` hook return value creates new reference on every render

**Impact**: Using it in `useEffect` dependency array causes infinite loops

**Solution**: Use `getState()` for actions inside effects/callbacks

```typescript
// âŒ BAD - Causes infinite loop
const store = useOpencodeStore()
useEffect(() => {
  store.initDirectory(directory)
}, [directory, store]) // store changes every render

// âœ… GOOD - Stable reference
useEffect(() => {
  useOpencodeStore.getState().initDirectory(directory)
}, [directory])

// âœ… GOOD - Helper function
const getStoreActions = () => useOpencodeStore.getState()
useEffect(() => {
  getStoreActions().initDirectory(directory)
}, [directory])
```

**Used in**:
- `factory.ts` - All factory hooks use `useCallback` with store selectors
- `opencode-provider.tsx` - Uses `getStoreActions()` helper

---

### 3. Sub-Agent Status Detection

**Pattern**: Combine main session status + sub-agent activity

**Rationale**: Sub-agents (spawned via Task tool) run independently but should keep session indicator green

**Implementation**:
1. Check main `sessionStatus[sessionId]` first
2. If not running, scan all task parts in session messages
3. Return "running" if any task part has `status === "running"`

**Impact**: Prevents "idle" indicator while sub-agents are actively working

---

### 4. Bootstrap + SSE Two-Phase Loading

**Pattern**: Load initial data via API, then rely on SSE for updates

**Rationale**: Prevents blank screen on mount, ensures app works even if SSE connection delayed

**Implementation**:
1. **Bootstrap phase** (OpencodeProvider): Fetch sessions, statuses, model limits
2. **SSE phase** (useSSESync): Real-time updates via event stream
3. Graceful degradation: App remains usable if bootstrap fails

**Multi-Directory Status**: Additional bootstrap phase fetches status for recent sessions (<5min) by checking last message completion.

---

### 5. Cooldown UX Smoothing

**Pattern**: 1-minute cooldown before transitioning "running" â†’ "completed"

**Rationale**: Prevents UI flicker during AI streaming pauses

**Tradeoff**: Indicator may stay green for up to 1 minute after session completes

**Implementation**:
- `useMultiDirectoryStatus` uses `setTimeout` timers tracked in `Map<sessionId, timer>`
- Timer canceled if status returns to "running" before expiry
- All timers cleaned up on unmount

---

### 6. Ring Buffer for Event History

**Pattern**: Cap event array at 100 items (FIFO)

**Rationale**: Prevents memory leaks during long-running sessions

**Implementation** (`use-sse.ts` lines 104-108):
```typescript
setEvents((prev) => {
  const next = [...prev, data]
  return next.length > MAX_EVENTS ? next.slice(-MAX_EVENTS) : next
})
```

**Impact**: After 8-hour session with frequent events, prevents 17+ MB leak

---

## Duplication & Improvement Opportunities

### 1. Duplicate Status Hooks

**Current State**:
- `use-session-status.ts` (internal) - Simple store selector
- Factory's `useSessionStatus` (public) - With sub-agent detection

**Opportunity**: Remove internal version, only expose factory version. Internal version is dead code (not imported anywhere except internally).

**Impact**: Reduced confusion, single source of truth.

---

### 2. Deprecated `useSSE` Hook

**Current State**: Still exported in factory, but marked deprecated with console.warn

**Opportunity**: Remove from public API in next major version

**Migration Path**: All consumers should use `useSSESync()` + store selectors

**Impact**: Clearer API surface, removes confusion.

---

### 3. Bootstrap Code Duplication

**Current State**:
- `OpencodeProvider` fetches sessions, statuses, model limits
- `useMultiDirectoryStatus` fetches statuses independently (for recent sessions)

**Opportunity**: Unify bootstrap logic in provider, expose initialization signal

**Impact**: Reduced API calls, faster initial load.

---

### 4. Status Derivation Logic Duplication

**Current State**:
- `useMultiDirectoryStatus` has `deriveSessionStatus()` (checks last message)
- Factory's `useSessionStatus` has inline logic (checks sessionStatus + task parts)

**Opportunity**: Extract shared status derivation utility

**Impact**: Single source of truth for status logic.

---

### 5. Model Limits Caching

**Current State**: Model limits cached in two places:
- Store's `modelLimits` map (from provider bootstrap)
- Message's `model.limits` (from backend)

**Opportunity**: Centralize model limits in store, always use cached version

**Impact**: Simplified logic, reduced state duplication.

---

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      REACT COMPONENT LAYER                       â”‚
â”‚  (uses factory hooks: useSession, useSessionStatus, etc.)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â”‚ Selectors (useOpencodeStore)
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ZUSTAND STORE (store.ts)                     â”‚
â”‚                                                                  â”‚
â”‚  directories: {                                                  â”‚
â”‚    "/project1": {                                                â”‚
â”‚      sessions: Session[]          (sorted, binary search)        â”‚
â”‚      sessionStatus: { [id]: "running" | "completed" }            â”‚
â”‚      messages: { [sessionId]: Message[] }                        â”‚
â”‚      parts: { [messageId]: Part[] }                              â”‚
â”‚      ...                                                         â”‚
â”‚    },                                                            â”‚
â”‚    "/project2": { ... }                                          â”‚
â”‚  }                                                               â”‚
â”‚                                                                  â”‚
â”‚  Actions:                                                        â”‚
â”‚  - handleSSEEvent(event) â†’ handleEvent(directory, payload)       â”‚
â”‚  - setSessions, setMessages, setParts                            â”‚
â”‚  - initDirectory (auto-create on first event)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â”‚ handleSSEEvent({ directory, payload })
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   OPENCODE PROVIDER LAYER                        â”‚
â”‚                                                                  â”‚
â”‚  useMultiServerSSE({ onEvent: handleEvent })                     â”‚
â”‚    â†“                                                             â”‚
â”‚  multiServerSSE.onEvent((event) => {                             â”‚
â”‚    store.handleSSEEvent(event) // Process ALL directories        â”‚
â”‚  })                                                              â”‚
â”‚                                                                  â”‚
â”‚  Bootstrap:                                                      â”‚
â”‚  - Fetch sessions (first 20 + recently updated)                  â”‚
â”‚  - Fetch session statuses                                        â”‚
â”‚  - Fetch providers (cache model limits)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â”‚ onEvent callback
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MULTI-SERVER SSE (core singleton)                   â”‚
â”‚                                                                  â”‚
â”‚  multiServerSSE.start()                                          â”‚
â”‚    â†“                                                             â”‚
â”‚  1. Discover servers (ports 4056-4066)                           â”‚
â”‚  2. Connect to each server's /sse endpoint                       â”‚
â”‚  3. Aggregate events from all servers                            â”‚
â”‚  4. Emit events via onEvent(callback)                            â”‚
â”‚                                                                  â”‚
â”‚  Events: { directory: string, payload: { type, properties } }    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Session Status Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             SESSION STATUS DETERMINATION FLOW                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SSE Event: session.status                                        â”‚
â”‚ { sessionID, status: { running: true } }                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Store: handleEvent("session.status")                             â”‚
â”‚                                                                  â”‚
â”‚ Normalizes to SessionStatus:                                     â”‚
â”‚ - { running: boolean } â†’ "running" | "completed"                 â”‚
â”‚ - { type: "busy" } â†’ "running"                                   â”‚
â”‚ - { type: "idle" } â†’ "completed"                                 â”‚
â”‚                                                                  â”‚
â”‚ Updates:                                                         â”‚
â”‚ - sessionStatus[sessionID] = status                              â”‚
â”‚ - sessionLastActivity[sessionID] = Date.now()                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Factory Hook: useSessionStatus(sessionId)                        â”‚
â”‚                                                                  â”‚
â”‚ 1. Check main status:                                            â”‚
â”‚    if (sessionStatus[sessionId] === "running") return "running"  â”‚
â”‚                                                                  â”‚
â”‚ 2. Check sub-agent activity:                                     â”‚
â”‚    for each message in session:                                  â”‚
â”‚      for each part in message:                                   â”‚
â”‚        if (part.type === "tool" && part.tool === "task" &&       â”‚
â”‚            part.state.status === "running")                      â”‚
â”‚          return "running"                                        â”‚
â”‚                                                                  â”‚
â”‚ 3. Return main status (default: "completed")                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Component: SessionIndicator                                      â”‚
â”‚                                                                  â”‚
â”‚ const status = useSessionStatus(sessionId)                       â”‚
â”‚ return status === "running" ? <GreenDot /> : <GrayDot />         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        MULTI-DIRECTORY STATUS (with 1-minute cooldown)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bootstrap Phase (on mount)                                       â”‚
â”‚                                                                  â”‚
â”‚ For recent sessions (< 5min old):                                â”‚
â”‚   Fetch last message                                             â”‚
â”‚   if (role === "assistant" && !time.completed)                   â”‚
â”‚     status = "running"                                           â”‚
â”‚   else                                                           â”‚
â”‚     status = "completed"                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SSE Subscription (via store)                                     â”‚
â”‚                                                                  â”‚
â”‚ store.subscribe((state) => {                                     â”‚
â”‚   for each directory:                                            â”‚
â”‚     for each (sessionId, status) in sessionStatus:               â”‚
â”‚                                                                  â”‚
â”‚       if (status === "running"):                                 â”‚
â”‚         - Cancel any pending cooldown timer                      â”‚
â”‚         - Set sessionStatuses[sessionId] = "running"             â”‚
â”‚         - Set lastActivity[sessionId] = Date.now()               â”‚
â”‚                                                                  â”‚
â”‚       if (status === "completed"):                               â”‚
â”‚         - Set lastActivity[sessionId] = Date.now()               â”‚
â”‚         - Start 1-minute cooldown timer                          â”‚
â”‚         - After timer expires: sessionStatuses[sessionId] =      â”‚
â”‚           "completed"                                            â”‚
â”‚ })                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Files Reference

### Core Files
- `packages/react/src/factory.ts` - Factory function, public hooks
- `packages/react/src/store/store.ts` - Zustand store, SSE integration
- `packages/react/src/store/types.ts` - Type definitions

### Internal Hooks
- `packages/react/src/hooks/internal/use-sse.ts` - Native EventSource hook (deprecated)
- `packages/react/src/hooks/internal/use-session-status.ts` - Simple store selector
- `packages/react/src/hooks/internal/use-multi-server-sse.ts` - Multi-server wrapper

### Multi-Directory Hooks
- `packages/react/src/hooks/use-multi-directory-sessions.ts` - Sessions across directories
- `packages/react/src/hooks/use-multi-directory-status.ts` - Status with cooldown

### Provider
- `packages/react/src/providers/opencode-provider.tsx` - Top-level integration

---

## Recommendations

### Immediate (Low Risk)
1. âœ… **Remove internal `use-session-status.ts`** - Dead code, factory version is canonical
2. âœ… **Document cooldown behavior** - Add comments explaining 1-minute delay tradeoff
3. âœ… **Add JSDoc to factory hooks** - Improve discoverability

### Short Term (Medium Risk)
4. âš ï¸ **Unify bootstrap logic** - Move multi-directory status bootstrap to provider
5. âš ï¸ **Extract status derivation utility** - Shared function for status logic
6. âš ï¸ **Deprecation plan for useSSE** - Remove in next major version

### Long Term (High Risk)
7. ğŸ”¥ **Centralize model limits** - Single source of truth in store
8. ğŸ”¥ **Event-driven connection status** - Replace polling with multiServerSSE events
9. ğŸ”¥ **Unified status hook** - Single hook for session status (single-dir + multi-dir)

---

## Conclusion

The React SSE architecture is **well-designed** with clear separation of concerns:

**Strengths**:
- âœ… Multi-directory support enables cross-project UIs
- âœ… Auto-initialization prevents silent event drops
- âœ… Binary search on sorted arrays ensures O(log n) updates
- âœ… Sub-agent detection keeps status accurate during parallel work
- âœ… Cooldown UX prevents janky flickering
- âœ… Graceful degradation (bootstrap + SSE two-phase loading)

**Areas for Improvement**:
- âš ï¸ Some duplication (status derivation, bootstrap logic)
- âš ï¸ Deprecated hook still exposed (useSSE)
- âš ï¸ Polling for connection status (could use events)
- âš ï¸ Model limits cached in multiple places

**Overall Assessment**: Architecture is production-ready. Recommended improvements are optimizations, not blockers.
